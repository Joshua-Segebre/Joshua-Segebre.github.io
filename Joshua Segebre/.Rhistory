library(rnaturalearth) # access to map data from Natural Earth
library(rnaturalearthdata)
library(tidyverse)
library(sf) # tools for working with spatial vector data (GIS functionality, mapping)
library(elevatr) # access to raster elevation maps
library(terra)
library(stars)
library(tidycensus) # spatial data for the US with census information
#library(USAboundaries) # access to boundaries for US states, counties, zip codes, and congressional districts
# The sf package comes with a North Carolina shapefile:
nc <- st_read(system.file("shape/nc.shp", package = "sf"))
# Read in shapefiles just downloaded
mn_cities <- st_read("../data/shp_loc_pop_centers/city_and_township_population_centers.shp")
setwd("~/Downloads")
library(tidyverse)
library(sf) # tools for working with spatial vector data (GIS functionality, mapping)
library(elevatr) # access to raster elevation maps
library(terra)
library(stars)
library(tidycensus) # spatial data for the US with census information
#library(USAboundaries) # access to boundaries for US states, counties, zip codes, and congressional districts
mn_water <- st_read("../data/shp_water_lakes_rivers/LakesAndRivers.shp")
# Read in shapefiles just downloaded
mn_cities <- st_read("../data/shp_loc_pop_centers/city_and_township_population_centers.shp")
class(nc)
class(mn_cities)
class(mn_water)
st_crs(nc)
ggplot(nc) +
geom_sf() +
theme_classic() +
labs(title = "NAD27")
nc_transformed <- nc %>% st_transform(crs = "EPSG:32133")
st_crs(nc_transformed)
ggplot(nc_transformed) +
geom_sf() +
theme_classic()
remotes::install_github("ropensci/USAboundaries")
knitr::opts_chunk$set(echo = TRUE, error = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(sf) # tools for working with spatial vector data
library(elevatr) # access to raster elevation maps
library(terra)
library(tidycensus) # spatial data for the US with census information
library(USAboundaries) # access to boundaries for US states, counties, zip codes, and congressional districts
library(rnaturalearth) # access to map data from Natural Earth
library(rnaturalearthdata)
library(tidyverse)
library(sf) # tools for working with spatial vector data (GIS functionality, mapping)
library(elevatr) # access to raster elevation maps
library(terra)
library(stars)
library(tidycensus) # spatial data for the US with census information
library(USAboundaries) # access to boundaries for US states, counties, zip codes, and congressional districts
# The sf package comes with a North Carolina shapefile:
nc <- st_read(system.file("shape/nc.shp", package = "sf"))
# Read in shapefiles just downloaded
mn_cities <- st_read("../data/shp_loc_pop_centers/city_and_township_population_centers.shp")
mn_water <- st_read("../data/shp_water_lakes_rivers/LakesAndRivers.shp")
class(nc)
class(mn_cities)
class(mn_water)
ggplot(nc) +
geom_sf() +
theme_classic() +
labs(title = "NAD27")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
library(USAboundaries)
remotes::install_github("ropensci/USAboundariesData")
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
library('USAboundariesData')
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
ggplot() +
#geom_sf(data = mn_counties, fill = "white") +
#geom_sf(data = mn_cities %>% filter(Population >= 10000), mapping = aes(color = Population, size = Population)) + # cities layer
scale_color_viridis_c() + # continuous (gradient) color scale
labs(title = "Minnesota Cities with Population >= 10,000") +
ggthemes::theme_map() +
theme(legend.position = "bottom") # move legend
install.packages("USAboundariesData", repos = "https://ropensci.r-universe.dev", type = "source")
knitr::opts_chunk$set(echo = TRUE, error = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(sf) # tools for working with spatial vector data
library(elevatr) # access to raster elevation maps
library(terra)
library(tidycensus) # spatial data for the US with census information
library(USAboundaries) # access to boundaries for US states, counties, zip codes, and congressional districts
library(rnaturalearth) # access to map data from Natural Earth
library(rnaturalearthdata)
library(tidyverse)
library(sf) # tools for working with spatial vector data (GIS functionality, mapping)
library(elevatr) # access to raster elevation maps
library(terra)
library(stars)
library(tidycensus) # spatial data for the US with census information
library(USAboundaries) # access to boundaries for US states, counties, zip codes, and congressional districts
# The sf package comes with a North Carolina shapefile:
nc <- st_read(system.file("shape/nc.shp", package = "sf"))
# Read in shapefiles just downloaded
mn_cities <- st_read("../data/shp_loc_pop_centers/city_and_township_population_centers.shp")
mn_water <- st_read("../data/shp_water_lakes_rivers/LakesAndRivers.shp")
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
# Take care of duplicate column names (there are two identical "state_name" columns)
names_counties <- names(mn_counties)
names(mn_counties)[names_counties == "state_name"] <- c("state_name1", "state_name2")
ggplot() +
#geom_sf(data = mn_counties, fill = "white") +
#geom_sf(data = mn_cities %>% filter(Population >= 10000), mapping = aes(color = Population, size = Population)) + # cities layer
scale_color_viridis_c() + # continuous (gradient) color scale
labs(title = "Minnesota Cities with Population >= 10,000") +
ggthemes::theme_map() +
theme(legend.position = "bottom") # move legend
ggplot() +
geom_sf(data = mn_counties, fill = "white") +
geom_sf(data = mn_cities %>% filter(Population >= 10000), mapping = aes(color = Population, size = Population)) + # cities layer
scale_color_viridis_c() + # continuous (gradient) color scale
labs(title = "Minnesota Cities with Population >= 10,000") +
ggthemes::theme_map() +
theme(legend.position = "bottom") # move legend
elevation <- elevatr::get_elev_raster(mn_counties, z = 5, clip = "bbox")
raster::crs(elevation) <- sf::st_crs(mn_counties)
# Convert to data frame for plotting
elev_df <- elevation %>% terra::as.data.frame(xy = TRUE)
colnames(elev_df) <- c("x", "y", "elevation")
seven_countyarea <- mn_counties %>%
filter(name %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott")) %>%
st_bbox()
seven_countyarea
elevation <- elevatr::get_elev_raster(mn_counties %>% st_crop(seven_countyarea), z = 9, clip = "bbox")
ggplot() +
geom_raster(data = elev_df, aes(x = x, y = y, fill = elevation)) +
geom_sf(data = mn_counties, fill = NA, color = "black") + # county boundary layer
geom_sf(data = mn_water, fill = "lightsteelblue1", color = "lightsteelblue1") + # NEW: river/lake layer
geom_sf(data = mn_cities %>% filter(Population >= 10000), mapping = aes(color = Population, size = Population)) + # cities layer
scale_color_viridis_c(option = "magma") + # continuous (gradient) color scale
scale_fill_gradient(low = "darkgreen", high = "white") + # continuous (gradient) fill scale
coord_sf(xlim = seven_countyarea[c("xmin", "xmax")], ylim = seven_countyarea[c("ymin", "ymax")]) + # NEW: crop map to Twin Cities bounding box
labs(title = "Twin Cities with Population >= 10,000") +
ggthemes::theme_map() +
theme(legend.position = "none") # remove legend
library(leaflet)
mn_counties_leaf <- mn_counties %>% st_transform(4326) # Leaflet expects this CRS for vectors
mn_cities_leaf <- mn_cities %>% st_transform(4326)
cities_per_county <- st_join(mn_cities_leaf, mn_counties_leaf) %>%
st_drop_geometry() %>% # removes geometry - makes the following calculation more efficient
count(name)
mn_counties_leaf %>%
filter(name %in% c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott")) %>%
left_join(cities_per_county) %>%
leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
color = "#444444", weight = 1, smoothFactor = 0.5, opacity = 1.0,
fillOpacity = 0.5, fillColor = ~colorQuantile("YlOrRd", n)(n),
highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = TRUE)) %>%
addCircles(data = mn_cities_leaf %>% filter(County %in% paste(c("Anoka", "Hennepin", "Ramsey", "Dakota", "Carver", "Washington", "Scott"), "County")), color = "#444444")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32132")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32135")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32134")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:6802")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:6802")
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
nc_transformed <- nc %>% st_transform(crs = "EPSG:32133")
st_crs(nc_transformed)
ggplot(nc_transformed) +
geom_sf() +
theme_classic()
transform_and_plot <- function(spatial_obj, new_crs) {
spatial_obj %>%
st_transform(crs = new_crs) %>%
ggplot() +
geom_sf() +
theme_classic()
}
# Example usage of this function (using a South Carolina CRS)
transform_and_plot(nc, new_crs = "EPSG:32133")
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
# Take care of duplicate column names (there are two identical "state_name" columns)
names_counties <- names(mn_counties)
names(mn_counties)[names_counties == "state_name"] <- c("state_name1", "state_name2")
# Load country boundaries data as sf object
mn_counties <- USAboundaries::us_counties(resolution = "high", states = "Minnesota")
# Take care of duplicate column names (there are two identical "state_name" columns)
names_counties <- names(mn_counties)
names(mn_counties)[names_counties == "state_name"] <- c("state_name1", "state_name2")
View(mn_counties)
View(mn_counties_leaf)
# Check CRSs
# Transform the CRS of county data to the more local CRS of the cities
# Check the new CRS for mn_counties
ggplot() +
geom_sf(data = mn_counties, fill = "white") +
geom_sf(data = mn_cities %>% filter(Population >= 10000), mapping = aes(color = Population, size = Population)) + # cities layer
scale_color_viridis_c() + # continuous (gradient) color scale
labs(title = "Minnesota Cities with Population >= 10,000") +
ggthemes::theme_map() +
theme(legend.position = "bottom") # move legend
# OPTIONAL: Set a more color blind friendly palette
palette("Okabe-Ito")
scale_colour_discrete <- function(...) scale_colour_manual(values = palette())
scale_fill_discrete   <- function(...) scale_fill_manual(values = palette())
knitr::opts_chunk$set(
collapse = TRUE,
warning = FALSE,
message = FALSE,
fig.height = 2.75,
fig.width = 4.25,
fig.env='figure',
fig.pos = 'h',
fig.align = 'center')
# Load packages we'll need to wrangle and plot the data
library(tidyverse)
# Load the data
bikes <- read.csv("https://mac-stat.github.io/data/bike_share.csv")
# Only keep / select some variables
# And round some variables (just for our demo purposes)
bikes <- bikes %>%
rename(rides = riders_registered, temp = temp_feel) %>%
mutate(windspeed = round(windspeed), temp = round(temp)) %>%
select(rides, windspeed, temp, weekend)
# Load packages
library(tidyverse)
library(tidymodels)
# STEP 1: specify the type of model to build
lm_spec <- linear_reg() %>% # we want a linear regression model
set_mode("regression") %>%  # this is a regression task (y is quantitative)
set_engine("lm")# we'll estimate the model using the lm function
# STEP 2: estimate the specified model using sample data
model_estimate <- lm_spec %>%
fit(y ~ x1 + x2, data = sample_data)
# STEP 1: specify the type of model to build
lm_spec <- linear_reg() %>% # we want a linear regression model
set_mode("regression") %>%  # this is a regression task (y is quantitative)
set_engine("lm")# we'll estimate the model using the lm function
# STEP 2: estimate the specified model using sample data
model_estimate <- lm_spec %>%
fit(y ~ x1 + x2, data = sample_data)
# Obtain y predictions and residuals for each observation in our sample_data
# (We can replace sample_data with any data frame that includes y, x1, and x2)
model_estimate %>%
augment(new_data = sample_data)
# Load packages we'll need to wrangle and plot the data
library(tidyverse)
# Load the data
bikes <- read.csv("https://mac-stat.github.io/data/bike_share.csv")
# Only keep / select some variables
# And round some variables (just for our demo purposes)
bikes <- bikes %>%
rename(rides = riders_registered, temp = temp_feel) %>%
mutate(windspeed = round(windspeed), temp = round(temp)) %>%
select(rides, windspeed, temp, weekend)
# Start small: rides vs temp
ggplot(___, aes(y = ___, x = ___)) +
ggplot(bikes, aes(y = rides, x = temp)) +
geom_points()
# OPTIONAL: Set a more color blind friendly palette
palette("Okabe-Ito")
scale_colour_discrete <- function(...) scale_colour_manual(values = palette())
scale_fill_discrete   <- function(...) scale_fill_manual(values = palette())
knitr::opts_chunk$set(
collapse = TRUE,
warning = FALSE,
message = FALSE,
fig.height = 2.75,
fig.width = 4.25,
fig.env='figure',
fig.pos = 'h',
fig.align = 'center')
# Load packages
library(tidyverse)
library(tidymodels)
# STEP 1: specify the type of model to build
lm_spec <- linear_reg() %>% # we want a linear regression model
set_mode("regression") %>%  # this is a regression task (y is quantitative)
set_engine("lm")# we'll estimate the model using the lm function
# STEP 2: estimate the specified model using sample data
model_estimate <- lm_spec %>%
fit(y ~ x1 + x2, data = sample_data)
# Obtain y predictions and residuals for each observation in our sample_data
# (We can replace sample_data with any data frame that includes y, x1, and x2)
model_estimate %>%
augment(new_data = sample_data)
# Is it strong? (R^2)
model_estimate %>%
glance()
ggplot(bikes, aes(y = rides, x = temp)) +
geom_point()
ggplot(bikes, aes(y = rides, x = temp + windspeed)) +
geom_point()
ggplot(bikes, aes(y = rides, x = temp, x2 = windspeed)) +
geom_point()
ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
geom_point()
ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
geom_point() +
facet_wrap(~ weekend)
# Load package
library(tidymodels)
lm_spec <- linear_reg() %>%   # we want a linear regression model
set_mode("regression") %>%  # this is a regression task (y is quantitative)
set_engine("lm")            # we'll estimate the model using the lm function
# Check it out
lm_spec
# Check it out
lm_spec
lm_spec <- linear_reg() %>%   # we want a linear regression model
set_mode(regression) %>%  # this is a regression task (y is quantitative)
set_engine(lm)            # we'll estimate the model using the lm function
# Fit bike_model_1
bike_model_1 <- lm_spec %>%
fit(rides ~ windspeed + temp, data = bikes)
# Check out the coefficients
bike_model_1 %>%
tidy()
# YOUR TURN
# Fit bike_model_2 & check out the coefficients
bike_model_2 <- lm_spec %>%
fit(rides ~ temp, color= windspeed, data = bikes) + facet_wrap(~weekend)
#ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
#geom_point() +
#facet_wrap(~ weekend)
# YOUR TURN
# Fit bike_model_2 & check out the coefficients
bike_model_2 <- lm_spec %>%
fit(rides ~ temp, color= windspeed, data = bikes) + facet_wrap(~weekend)
#ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
#geom_point() +
#facet_wrap(~ weekend)
# YOUR TURN
# Fit bike_model_2 & check out the coefficients
bike_model_2 <- lm_spec %>%
fit(rides ~ temp, color= windspeed, data = bikes) + facet_wrap(~weekend)
#ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
#geom_point() +
#facet_wrap(~ weekend)
# YOUR TURN
# Fit bike_model_2 & check out the coefficients
bike_model_2 <- lm_spec %>%
fit(rides ~ temp, color= windspeed, data = bikes) + facet_wrap(~weekend)
bike_model_2 %>% tidy()
#ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
#geom_point() +
#facet_wrap(~ weekend)
# YOUR TURN
# Fit bike_model_2 & check out the coefficients
bike_model_2 <- lm_spec %>%
fit(rides ~ temp + windspeed + weekend, data = bikes)
bike_model_2 %>% tidy()
#ggplot(bikes, aes(y = rides, x = temp, color = windspeed)) +
#geom_point() +
#facet_wrap(~ weekend)
# Obtain R^2 for bike_model_1
bike_model_1 %>%
glance()
# YOUR TURN
# Obtain R^2 for bike_model_2
bike_model_2 %>%
glance()
model_3 <- lm(temp3pm ~ raintoday, weather)
library(tidyverse)
install.packages("tidyverse", dependencies = TRUE)
# Import data
weather <- read_csv("https://mac-stat.github.io/data/weather_canberra.csv")
# Examine the first six data rows
# What are the units of observation? What are the variables?
head(weather)
# Find the dimensions of the data
# (How many units of observation & variables are there?)
dim(weather)
nrow(weather)
# Examine the variable names
names(weather)
# Histogram
ggplot(weather, aes(x = temp3pm)) +
geom_histogram(color = "white")
# Density plot
ggplot(weather, aes(x = temp3pm)) +
geom_density()
# Summary statistics
weather %>%
summarize(min(temp3pm), median(temp3pm), max(temp3pm))
ggplot(weather, aes(y = temp3pm, x = temp9am)) +
geom_point() +
geom_smooth(method = "lm")
# Fit the model
model_1 <- lm(temp3pm ~ temp9am, data = weather)
# Obtain a model summary
summary(model_1)
ggplot(weather, aes(y = temp3pm, x = temp9am, color = humidity9am)) +
geom_point(alpha = 0.5)
ggplot(weather, aes(y = temp3pm, x = temp9am, color = cut(humidity9am, 3))) +
geom_point(alpha = 0.5) +
facet_wrap(~ cut(humidity9am, 3))
ggplot(weather, aes(y = temp3pm, x = temp9am, size = humidity9am)) +
geom_point(alpha = 0.5)
model_2 <- lm(temp3pm ~ temp9am + humidity9am, data = weather)
summary(model_2)
ggplot(weather, aes(x = temp3pm, fill = raintoday)) +
geom_density(alpha = 0.5)
ggplot(weather, aes(x = temp3pm, fill = raintoday)) +
geom_density(alpha = 0.5) +
facet_wrap( ~ raintoday)
model_3 <- lm(temp3pm ~ raintoday, weather)
summary(model_3)
model_3 <- lm(temp3pm ~ noraintoday, weather)
install.packages("tidyverse", dependencies = TRUE)
model_3 <- lm(temp3pm ~ raintoday, weather)
summary(model_3)
View(model_3)
View(weather)
model_3 <- lm(temp3pm ~ Noraintoday, weather)
model_3 <- lm(temp3pm ~ raintoday==No, weather)
